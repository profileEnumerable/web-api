// Decompiled with JetBrains decompiler
// Type: System.Data.Entity.Migrations.Design.MigrationCodeGenerator
// Assembly: EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 000F5452-2AD1-45BF-987B-3043022F9799
// Assembly location: C:\Users\suckt\source\repos\Epam_Lab_Task\packages\EntityFramework.6.1.3\lib\net45\EntityFramework.dll

using System.Collections.Generic;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure.Annotations;
using System.Data.Entity.Migrations.Model;
using System.Data.Entity.Utilities;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace System.Data.Entity.Migrations.Design
{
  /// <summary>
  /// Base class for providers that generate code for code-based migrations.
  /// </summary>
  public abstract class MigrationCodeGenerator
  {
    private readonly IDictionary<string, Func<AnnotationCodeGenerator>> _annotationGenerators = (IDictionary<string, Func<AnnotationCodeGenerator>>) new Dictionary<string, Func<AnnotationCodeGenerator>>();

    /// <summary>
    /// Generates the code that should be added to the users project.
    /// </summary>
    /// <param name="migrationId"> Unique identifier of the migration. </param>
    /// <param name="operations"> Operations to be performed by the migration. </param>
    /// <param name="sourceModel"> Source model to be stored in the migration metadata. </param>
    /// <param name="targetModel"> Target model to be stored in the migration metadata. </param>
    /// <param name="namespace"> Namespace that code should be generated in. </param>
    /// <param name="className"> Name of the class that should be generated. </param>
    /// <returns> The generated code. </returns>
    [SuppressMessage("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords", MessageId = "namespace")]
    public abstract ScaffoldedMigration Generate(
      string migrationId,
      IEnumerable<MigrationOperation> operations,
      string sourceModel,
      string targetModel,
      string @namespace,
      string className);

    [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
    private static bool AnnotationsExist(MigrationOperation[] operations)
    {
      return operations.OfType<IAnnotationTarget>().Any<IAnnotationTarget>((Func<IAnnotationTarget, bool>) (o => o.HasAnnotations));
    }

    /// <summary>
    /// Gets the namespaces that must be output as "using" or "Imports" directives to handle
    /// the code generated by the given operations.
    /// </summary>
    /// <param name="operations"> The operations for which code is going to be generated. </param>
    /// <returns> An ordered list of namespace names. </returns>
    protected virtual IEnumerable<string> GetNamespaces(
      IEnumerable<MigrationOperation> operations)
    {
      Check.NotNull<IEnumerable<MigrationOperation>>(operations, nameof (operations));
      IEnumerable<string> strings = this.GetDefaultNamespaces(false);
      MigrationOperation[] array = operations.ToArray<MigrationOperation>();
      if (array.OfType<AddColumnOperation>().Any<AddColumnOperation>((Func<AddColumnOperation, bool>) (o =>
      {
        if (o.Column.Type != PrimitiveTypeKind.Geography)
          return o.Column.Type == PrimitiveTypeKind.Geometry;
        return true;
      })))
        strings = strings.Concat<string>((IEnumerable<string>) new string[1]
        {
          "System.Data.Entity.Spatial"
        });
      if (MigrationCodeGenerator.AnnotationsExist(array))
        strings = this.AnnotationGenerators.Select<KeyValuePair<string, Func<AnnotationCodeGenerator>>, Func<AnnotationCodeGenerator>>((Func<KeyValuePair<string, Func<AnnotationCodeGenerator>>, Func<AnnotationCodeGenerator>>) (a => a.Value)).Where<Func<AnnotationCodeGenerator>>((Func<Func<AnnotationCodeGenerator>, bool>) (g => g != null)).Aggregate<Func<AnnotationCodeGenerator>, IEnumerable<string>>(strings.Concat<string>((IEnumerable<string>) new string[2]
        {
          "System.Collections.Generic",
          "System.Data.Entity.Infrastructure.Annotations"
        }), (Func<IEnumerable<string>, Func<AnnotationCodeGenerator>, IEnumerable<string>>) ((c, g) => c.Concat<string>(g().GetExtraNamespaces((IEnumerable<string>) this.AnnotationGenerators.Keys))));
      return (IEnumerable<string>) strings.Distinct<string>().OrderBy<string, string>((Func<string, string>) (n => n));
    }

    /// <summary>
    /// Gets the default namespaces that must be output as "using" or "Imports" directives for
    /// any code generated.
    /// </summary>
    /// <param name="designer"> A value indicating if this class is being generated for a code-behind file. </param>
    /// <returns> An ordered list of namespace names. </returns>
    [SuppressMessage("Microsoft.Design", "CA1026:DefaultParametersShouldNotBeUsed")]
    protected virtual IEnumerable<string> GetDefaultNamespaces(bool designer = false)
    {
      List<string> source = new List<string>()
      {
        "System.Data.Entity.Migrations"
      };
      if (designer)
      {
        source.Add("System.CodeDom.Compiler");
        source.Add("System.Data.Entity.Migrations.Infrastructure");
        source.Add("System.Resources");
      }
      else
        source.Add("System");
      return (IEnumerable<string>) source.OrderBy<string, string>((Func<string, string>) (n => n));
    }

    /// <summary>
    /// Gets the <see cref="T:System.Data.Entity.Infrastructure.Annotations.AnnotationCodeGenerator" /> instances that are being used.
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
    public virtual IDictionary<string, Func<AnnotationCodeGenerator>> AnnotationGenerators
    {
      get
      {
        return this._annotationGenerators;
      }
    }
  }
}
